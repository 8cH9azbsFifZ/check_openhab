#!/usr/bin/python

import datetime
import json
import re
import sys
import urllib
import urllib2

import dateutil.parser
import dateutil.relativedelta

from optparse import OptionParser

RC_OK   = 0
RC_WARN = 1
RC_CRIT = 2
RC_UNKN = 3

options_epilog = """The warn, crit, warn-time, and crit-time parameters
take a pair of values separated by a colon.  Either side of the colon may
be empty, which implies no threshold in that direction.  e.g. "1:2"
indicates that the acceptable values for the check range from 1 to 2,
inclusive.  ":5" gives an upper threshold of 5 and no lower threshold.

The time-based thresholds use ISO 8601 formatting, with no readability
characters ("-" or ":").  Time-based thresholds can either be absolute
dates or time periods (which start with the character "P").  Time periods
are relative to the time the check is run."""
parser = OptionParser(epilog=options_epilog)
parser.add_option('-I', '--item', help='The item to check.  Required.')
parser.add_option('-H', '--hostname', default='localhost', help='Hostname of the OpenHAB instance.  Defaults to localhost.')
parser.add_option('-p', '--port', type='int', default=8080, help='Port number of the OpenHAB instance.  Defaults to 8080.')
parser.add_option('-S', '--ssl', action='store_true', help='Use SSL when connecting.  Default is not to use SSL.')
parser.add_option('-a', '--authorization', help='username:password pair to use when connecting.')
parser.add_option('-u', '--base-url', default='/rest', help='Base path for the REST API.  Defaults to /rest.')
parser.add_option('-w', '--warn', help='low:high pair of integers to set thresholds for a WARNING status.  Either integer may be absent to indicate no threshold in that direction.')
parser.add_option('-c', '--crit', help='low:high pair of integers to set thresholds for a CRITICAL status.  Either integer may be absent to indicate no threshold in that direction.')
parser.add_option('-r', '--regex', help='Regular expression to search for in string values.  Returns CRITICAL if pattern is not found.')
parser.add_option(      '--invert-regex', action='store_true', help='Reverses the return values for the --regex parameter: CRITICAL if pattern *is* found, OK if it isn\'t.')
parser.add_option(      '--warn-time', help='low:high pair of timestamps or time periods which constitute WARNING thresholds for DateTime items.  See below for information on formatting.')
parser.add_option(      '--crit-time', help='low:high pair of timestamps or time periods which constitute CRITICAL thresholds for DateTime items.  See below for information on formatting.')
parser.add_option('-U', '--uninitialized-status', choices=('OK', 'WARNING', 'CRITICAL', 'UNKNOWN'), default='UNKNOWN', help='The status that should be returned if the item\'s state is "Uninitialized".  Defaults to UNKNOWN.')
parser.add_option('-v', '--verbose', action='store_true')

iso8601_duration_re = \
    re.compile(r"""^P(?:(?:(\d+)Y)?
                        (?:(\d+)M)?
                        (?:(\d+)D)?
                        (?:T(?:(\d+)H)?
                            (?:(\d+)M)?
                            (?:(\d+)S)?)?
                        |
                        (\d+)W)$""", re.X)

def parse_iso8601(value, forward):
    period_match = iso8601_duration_re.search(value)
    if period_match:
        multiplier = 1 if forward else -1
        years, months, days, hours, minutes, seconds, weeks = [ int(i) * multiplier if i else 0 for i in period_match.groups() ]
        return datetime.datetime.now() + dateutil.relativedelta.relativedelta(years=years, months=months, days=days, hours=hours, minutes=minutes, seconds=seconds, weeks=weeks)
    return dateutil.parser.parse(value, default=datetime.datetime(1, 1, 1))

def split_threshold(value, level, convert):
    if value is None:
        return (None, None)
    items = value.split(':')
    if len(items) != 2:
        print 'Malformed %s value: %s' % (level, value)
        sys.exit(RC_UNKN)
    try:
        return [ None if i == '' else convert(i, f) for i, f in zip(items, (False, True)) ]
    except:
        print 'Invalid value passed as %s parameter: %s' % (level, value)
        sys.exit(RC_UNKN)

def check_limits(state, low, high, name, return_code):
    if low is not None and state <= low:
        print '%s state (%s) is less than %s' % (name, state, low)
        sys.exit(return_code)
    elif high is not None and high <= state:
        print '%s state (%s) is greater than %s' % (name, state, high)
        sys.exit(return_code)

        
if __name__ == '__main__':
    (options, args) = parser.parse_args()
    
    warn_low, warn_high = split_threshold(options.warn, 'warn', lambda i, f: float(i))
    crit_low, crit_high = split_threshold(options.crit, 'crit', lambda i, f: float(i))
    if options.verbose:
        print >>sys.stderr, '# numeric thresholds: %s << %s < x > %s >> %s' % (crit_low, warn_low, warn_high, crit_high)

    warn_time_low, warn_time_high = split_threshold(options.warn_time, 'warn-time', lambda i, f: parse_iso8601(i, f))
    crit_time_low, crit_time_high = split_threshold(options.crit_time, 'crit-time', lambda i, f: parse_iso8601(i, f))
    if options.verbose:
        print >>sys.stderr, '# time thresholds: %s << %s < x > %s >> %s' % (crit_time_low, warn_time_low, warn_time_high, crit_time_high)

    if options.item is None:
        print 'No item given.'
        sys.exit(RC_UNKN)
    
    if options.regex is not None:
        try:
            compiled_regex = re.compile(options.regex)
        except:
            print 'Unable to compile regex:', options.regex
            sys.exit(RC_UNKN)

    item_url = '%s://%s:%d%s/items/%s' % \
               ('https' if options.ssl else 'http', options.hostname, options.port, options.base_url, options.item)
    if options.verbose:
        print >>sys.stderr, '# %s' % item_url
    
    password_manager = urllib2.HTTPPasswordMgrWithDefaultRealm()
    if options.authorization is not None:
        auth_params = options.authorization.split(':')
        if len(auth_params) != 2:
            print 'Authorization parameters not in "username:password" format.'
            sys.exit(RC_UNKN)
        password_manager.add_password(None, item_url, auth_params[0], auth_params[1])
    auth_handler = urllib2.HTTPBasicAuthHandler(password_manager)
    url_opener = urllib2.build_opener(auth_handler)
    urllib2.install_opener(url_opener)
        
    item_request = urllib2.Request(item_url)
    item_request.add_header('Accept', 'application/json')
    try:
        item_raw = urllib2.urlopen(item_request)
    except urllib2.HTTPError, e:
        if e.code == 404:
            print 'Item "%s" does not exist.' % options.item
            sys.exit(RC_UNKN)
        print 'Exception fetching item data:', e
        sys.exit(RC_UNKN)
    except Exception, e:
        print 'Exception fetching item data:', e
        sys.exit(RC_UNKN)
    
    item_json = json.load(item_raw)
    if options.verbose:
        print '# %s' % json.dumps(item_json)
    
    if item_json['state'] in ('Uninitialized', 'Undefined'):
        print '%s is uninitialized.' % item_json['name']
        if options.uninitialized_status == 'OK':
            sys.exit(RC_OK)
        elif options.uninitialized_status == 'WARNING':
            sys.exit(RC_WARN)
        elif options.uninitialized_status == 'CRITICAL':
            sys.exit(RC_CRIT)
        elif options.uninitialized_status == 'UNKNOWN':
            sys.exit(RC_UNKN)
        else:
            sys.exit(RC_UNKN)
        
    if options.warn is not None or options.crit is not None:
        try:
            state = float(item_json['state'])
        except ValueError:
            print 'Numeric thresholds given for non-numeric state: "%s"' % item_json['state']
            sys.exit(RC_UNKN)
        check_limits(state, crit_low, crit_high, item_json['name'], RC_CRIT)
        check_limits(state, warn_low, warn_high, item_json['name'], RC_WARN)
    
    if options.warn_time is not None or options.crit_time is not None:
        try:
            state = dateutil.parser.parse(item_json['state'])
        except ValueError:
            print 'Time thresholds given for non-time state: "%s"' % item_json['state']
            sys.exit(RC_UNKN)
        check_limits(state, crit_time_low, crit_time_high, item_json['name'], RC_CRIT)
        check_limits(state, warn_time_low, warn_time_high, item_json['name'], RC_WARN)
    
    if options.regex is not None:
        if options.invert_regex:
            rc_match, rc_nomatch = RC_CRIT, RC_OK
        else:
            rc_match, rc_nomatch = RC_OK, RC_CRIT
        if compiled_regex.search(item_json['state']):
            print '%s regex "%s" matched state: %s' % (item_json['name'], options.regex, item_json['state'])
            sys.exit(rc_match)
        else:
            print '%s regex "%s" did not match state: %s' % (item_json['name'], options.regex, item_json['state'])
            sys.exit(rc_nomatch)
    
    print '%s state within bounds: %s' % (item_json['name'], item_json['state'])
    sys.exit(RC_OK)
    
